# test

- **dwb_create_internal**
    - 코드
        
        ```cpp
        /*
         * dwb_create_internal () - Create double write buffer.
         *
         * return   : Error code.
         * thread_p (in): The thread entry.
         * dwb_volume_name (in) : The double write buffer volume name.
         * current_position_with_flags (in/out): Current position with flags.
         *
         *  Note: Is user responsibility to ensure that no other transaction can access DWB structure, during creation.
         */
        STATIC_INLINE int
        dwb_create_internal (THREAD_ENTRY * thread_p, const char *dwb_volume_name, UINT64 * current_position_with_flags)
        {
          int error_code = NO_ERROR;
          unsigned int double_write_buffer_size, num_blocks = 0;
          unsigned int i, num_pages, num_block_pages;
          int vdes = NULL_VOLDES;
          DWB_BLOCK *blocks = NULL;
          UINT64 new_position_with_flags;
        
          const int freelist_block_count = 2;
          const int freelist_block_size = DWB_SLOTS_FREE_LIST_SIZE;
        
          assert (dwb_volume_name != NULL && current_position_with_flags != NULL);
        
          double_write_buffer_size = prm_get_integer_value (PRM_ID_DWB_SIZE);
          num_blocks = prm_get_integer_value (PRM_ID_DWB_BLOCKS);
          if (double_write_buffer_size == 0 || num_blocks == 0)
            {
              /* Do not use double write buffer. */
              return NO_ERROR;
            }
        
          dwb_adjust_write_buffer_values (&double_write_buffer_size, &num_blocks);
        
          num_pages = double_write_buffer_size / IO_PAGESIZE;
          num_block_pages = num_pages / num_blocks;
        
          assert (IS_POWER_OF_2 (num_blocks));
          assert (IS_POWER_OF_2 (num_pages));
          assert (IS_POWER_OF_2 (num_block_pages));
          assert (num_blocks <= DWB_MAX_BLOCKS);
        
          /* Create and open DWB volume first */
          vdes = fileio_format (thread_p, boot_db_full_name (), dwb_volume_name, LOG_DBDWB_VOLID, num_block_pages, true,
        			false, false, IO_PAGESIZE, 0, false);
          if (vdes == NULL_VOLDES)
            {
              goto exit_on_error;
            }
        
          /* Needs to flush dirty page before activating DWB. */
          fileio_synchronize_all (thread_p, false);
        
          /* Create DWB blocks */
          error_code = dwb_create_blocks (thread_p, num_blocks, num_block_pages, &blocks);
          if (error_code != NO_ERROR)
            {
              goto exit_on_error;
            }
        
          dwb_Global.blocks = blocks;
          dwb_Global.num_blocks = num_blocks;
          dwb_Global.num_pages = num_pages;
          dwb_Global.num_block_pages = num_block_pages;
          dwb_Global.log2_num_block_pages = (unsigned int) (log ((float) num_block_pages) / log ((float) 2));
          dwb_Global.blocks_flush_counter = 0;
          dwb_Global.next_block_to_flush = 0;
          pthread_mutex_init (&dwb_Global.mutex, NULL);
          dwb_init_wait_queue (&dwb_Global.wait_queue);
          dwb_Global.vdes = vdes;
          dwb_Global.file_sync_helper_block = NULL;
        
          dwb_Global.slots_hashmap.init (dwb_slots_Ts, THREAD_TS_DWB_SLOTS, DWB_SLOTS_HASH_SIZE, freelist_block_size,
        				 freelist_block_count, slots_entry_Descriptor);
        
          /* Set creation flag. */
          new_position_with_flags = DWB_RESET_POSITION (*current_position_with_flags);
          new_position_with_flags = DWB_STARTS_CREATION (new_position_with_flags);
          if (!ATOMIC_CAS_64 (&dwb_Global.position_with_flags, *current_position_with_flags, new_position_with_flags))
            {
              /* Impossible. */
              assert (false);
            }
          *current_position_with_flags = new_position_with_flags;
        
          return NO_ERROR;
        
        exit_on_error:
          if (vdes != NULL_VOLDES)
            {
              fileio_dismount (thread_p, vdes);
              fileio_unformat (NULL, dwb_volume_name);
            }
        
          if (blocks != NULL)
            {
              for (i = 0; i < num_blocks; i++)
        	{
        	  dwb_finalize_block (&blocks[i]);
        	}
              free_and_init (blocks);
            }
        
          return error_code;
        }
        ```
        
    - 설명 :
    - prm_get_integer_value
        - 코드
            
            ```cpp
            #define PRM_IS_INTEGER(x)         ((x)->datatype == PRM_INTEGER)
            #define PRM_IS_KEYWORD(x)         ((x)->datatype == PRM_KEYWORD)
            #define PRM_GET_INT(x)      (*((int *) (x)))
            /*
             * prm_get_integer_value () - get the value of a parameter of type integer
             *
             * return      : value
             * prm_id (in) : parameter id
             *
             * NOTE: keywords are stored as integers
             */
            int
            prm_get_integer_value (PARAM_ID prm_id)
            {
              assert (prm_id <= PRM_LAST_ID);
              assert (PRM_IS_INTEGER (&prm_Def[prm_id]) || PRM_IS_KEYWORD (&prm_Def[prm_id]));
            
              return PRM_GET_INT (prm_get_value (prm_id));
            }
            /*
             * prm_get_value () - returns a pointer to the value of a system parameter
             *
             * return      : pointer to value
             * prm_id (in) : parameter id
             *
             * NOTE: for session parameters, in server mode, the value stored in
             *	 conn_entry->session_parameters is returned instead of the value
             *	 from prm_Def array.
             */
            void *
            prm_get_value (PARAM_ID prm_id)
            {
            #if defined (SERVER_MODE)
              THREAD_ENTRY *thread_p;
            
              assert (prm_id <= PRM_LAST_ID);
            
              if (PRM_SERVER_SESSION (prm_id) && BO_IS_SERVER_RESTARTED ())
                {
                  SESSION_PARAM *sprm;
                  thread_p = thread_get_thread_entry_info ();
                  sprm = session_get_session_parameter (thread_p, prm_id);
                  if (sprm)
            	{
            	  return &(sprm->value);
            	}
                }
            
              return prm_Def[prm_id].value;
            #else /* SERVER_MODE */
              assert (prm_id <= PRM_LAST_ID);
            
              return prm_Def[prm_id].value;
            #endif /* SERVER_MODE */
            }
            ```
            
        - 설명 : 인자로 들어온 system parameter 의 값을 반환한다.
    - dwb_adjust_write_buffer_value
        - 코드
            
            ```cpp
            /*
             * dwb_adjust_write_buffer_values () - Adjust double write buffer values.
             *
             * return   : Error code.
             * p_double_write_buffer_size (in/out) : Double write buffer size.
             * p_num_blocks (in/out): The number of blocks.
             *
             *  Note: The buffer size must be a multiple of 512 K. The number of blocks must be a power of 2.
             */
            STATIC_INLINE void
            dwb_adjust_write_buffer_values (unsigned int *p_double_write_buffer_size, unsigned int *p_num_blocks)
            {
              unsigned int min_size;
              unsigned int max_size;
            
              assert (p_double_write_buffer_size != NULL && p_num_blocks != NULL
            	  && *p_double_write_buffer_size > 0 && *p_num_blocks > 0);
            
              min_size = DWB_MIN_SIZE;
              max_size = DWB_MAX_SIZE;
            // #define DWB_MIN_SIZE			    (512 * 1024)
            // #define DWB_MAX_SIZE			    (32 * 1024 * 1024)
            
              if (*p_double_write_buffer_size < min_size)
                {
                  *p_double_write_buffer_size = min_size;
                }
              else if (*p_double_write_buffer_size > min_size)
                {
                  if (*p_double_write_buffer_size > max_size)
            	{
            	  *p_double_write_buffer_size = max_size;
            	}
                  else
            	{
            	  /* find smallest number multiple of 512 k */
            	  unsigned int limit1 = min_size;
            
            	  while (*p_double_write_buffer_size > limit1) // buffersize를 512K 의 2의 배수로 맞추기위한 비교와 비트연산의 반복
            	    {
            	      assert (limit1 <= DWB_MAX_SIZE);
            	      if (limit1 == DWB_MAX_SIZE)
            		{
            		  break;
            		}
            	      limit1 = limit1 << 1;
            	    }
            
            	  *p_double_write_buffer_size = limit1;
            	}
                }
            
              min_size = DWB_MIN_BLOCKS;
              max_size = DWB_MAX_BLOCKS;
            //#define DWB_MIN_BLOCKS			    1
            //#define DWB_MAX_BLOCKS			    32
            
              assert (*p_num_blocks >= min_size);
            
              if (*p_num_blocks > min_size)
                {
                  if (*p_num_blocks > max_size)
            	{
            	  *p_num_blocks = max_size;
            	}
                  else if (!IS_POWER_OF_2 (*p_num_blocks))
            	{
            	  unsigned int num_blocks = *p_num_blocks;
            
            	  do
            	    {
            	      num_blocks = num_blocks & (num_blocks - 1);
            	    }
            	  while (!IS_POWER_OF_2 (num_blocks));
            
            	  *p_num_blocks = num_blocks << 1;
            
            	  assert (*p_num_blocks <= max_size);
            	}
                }
            }
            //#define IS_POWER_OF_2(x)        (((x) & ((x) - 1)) == 0)
            ```
            
        - 설명 : p_double_write_buffer_size 를 512K 의 2의 배수로 조정 DWB_MIN_SIZE 보다 작으면 DWB_MIN_SIZE로 DWB_MAX_SIZE보다 크면 DWB_MAX_SIZE로 조정 마찬가지로 num_block 도 2의 배수로 수정
    - fileio_format
        - 코드
            
            ```cpp
            fileio_format (thread_p, boot_db_full_name (), dwb_volume_name, LOG_DBDWB_VOLID, num_block_pages, true,
            			false, false, IO_PAGESIZE, 0, false);
            /*
             * fileio_format () - Format a volume of npages and mount the volume
             *   return: volume descriptor identifier on success, NULL_VOLDES on failure
             *   db_fullname(in): Name of the database where the volume belongs
             *   vlabel(in): Volume label
             *   volid(in): Volume identifier
             *   npages(in): Number of pages
             *   sweep_clean(in): Clean the newly formatted volume
             *   dolock(in): Lock the volume from other Unix processes
             *   dosync(in): synchronize the writes on the volume ?
             *   kbytes_to_be_written_per_sec : size to add volume per sec
             *
             * Note: If sweep_clean is true, every page is initialized with recovery
             *       information. In addition a volume can be optionally locked.
             *       For example, the active log volume is locked to prevent
             *       several server processes from accessing the same database.
             */
            int
            fileio_format (THREAD_ENTRY * thread_p, const char *db_full_name_p, const char *vol_label_p, VOLID vol_id,
            	       DKNPAGES npages, bool is_sweep_clean, bool is_do_lock, bool is_do_sync, size_t page_size,
            	       int kbytes_to_be_written_per_sec, bool reuse_file)
            {
              int vol_fd;
              FILEIO_PAGE *malloc_io_page_p;
              off_t offset;
              DKNPAGES max_npages;
            #if !defined(WINDOWS)
              struct stat buf;
            #endif
              bool is_raw_device = false;
            
              /* Check for bad number of pages...and overflow */
              if (npages <= 0)
                {
                  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_FORMAT_BAD_NPAGES, 2, vol_label_p, npages);
                  return NULL_VOLDES;
                }
            
              if (fileio_is_volume_exist (vol_label_p) == true && reuse_file == false)
                {
                  /* The volume that we are trying to create already exist. Remove it and try again */
            #if !defined(WINDOWS)
                  if (lstat (vol_label_p, &buf) != 0)
            	{
            	  er_set_with_oserror (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_MOUNT_FAIL, 1, vol_label_p);
            	}
            
                  if (!S_ISLNK (buf.st_mode))
            	{
            	  fileio_unformat (thread_p, vol_label_p);
            	}
                  else
            	{
            	  if (stat (vol_label_p, &buf) != 0)
            	    {
            	      er_set_with_oserror (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_MOUNT_FAIL, 1, vol_label_p);
            	    }
            
            	  is_raw_device = S_ISCHR (buf.st_mode);
            	}
            #else /* !WINDOWS */
                  fileio_unformat (thread_p, vol_label_p);
                  is_raw_device = false;
            #endif /* !WINDOWS */
                }
            
              if (is_raw_device)
                {
                  max_npages = (DKNPAGES) VOL_MAX_NPAGES (page_size);
                }
              else
                {
                  max_npages = fileio_get_number_of_partition_free_pages (vol_label_p, page_size);
                }
            
              offset = FILEIO_GET_FILE_SIZE (page_size, npages - 1);
            
              /*
               * Make sure that there is enough pages on the given partition before we
               * create and initialize the volume.
               * We should also check for overflow condition.
               */
              if (npages > max_npages || (offset < npages && npages > 1))
                {
                  if (offset < npages)
            	{
            	  /* Overflow */
            	  offset = FILEIO_GET_FILE_SIZE (page_size, VOL_MAX_NPAGES (page_size));
            	}
            
                  if (max_npages >= 0)
            	{
            	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_FORMAT_OUT_OF_SPACE, 5, vol_label_p, npages, (offset / 1024),
            		  max_npages, FILEIO_GET_FILE_SIZE (page_size / 1024, max_npages));
            	}
                  else
            	{
            	  /* There was an error in fileio_get_number_of_partition_free_pages */
            	  ;
            	}
            
                  return NULL_VOLDES;
                }
            
              malloc_io_page_p = (FILEIO_PAGE *) malloc (page_size);
              if (malloc_io_page_p == NULL)
                {
                  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1, page_size);
                  return NULL_VOLDES;
                }
            
              memset ((char *) malloc_io_page_p, 0, page_size);
              (void) fileio_initialize_res (thread_p, malloc_io_page_p, (PGLENGTH) page_size);
            
              vol_fd = fileio_create (thread_p, db_full_name_p, vol_label_p, vol_id, is_do_lock, is_do_sync);
              FI_TEST (thread_p, FI_TEST_FILE_IO_FORMAT, 0);
              if (vol_fd != NULL_VOLDES)
                {
                  /* initialize the pages of the volume. */
            
                  /* initialize at least two pages, the header page and the last page. in case of is_sweep_clean == true, every
                   * page of the volume will be written. */
            
                  if (fileio_write_or_add_to_dwb (thread_p, vol_fd, malloc_io_page_p, 0, page_size) == NULL)
            	{
            	  fileio_dismount (thread_p, vol_fd);
            	  fileio_unformat (thread_p, vol_label_p);
            	  free_and_init (malloc_io_page_p);
            
            	  if (er_errid () != ER_INTERRUPTED)
            	    {
            	      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_WRITE, 2, 0, vol_id);
            	    }
            
            	  vol_fd = NULL_VOLDES;
            	  return vol_fd;
            	}
            
            #if defined(HPUX)
                  if ((is_sweep_clean == true
            	   && !fileio_initialize_pages (vol_fd, malloc_io_page_p, npages, page_size, kbytes_to_be_written_per_sec))
            	  || (is_sweep_clean == false
            	      && !fileio_write (vol_fd, malloc_io_page_p, npages - 1, page_size, FILEIO_WRITE_DEFAULT_WRITE)))
            #else /* HPUX */
                  if (!((fileio_write_or_add_to_dwb (thread_p, vol_fd, malloc_io_page_p, npages - 1, page_size) == malloc_io_page_p)
            	    && (is_sweep_clean == false
            		|| fileio_initialize_pages (thread_p, vol_fd, malloc_io_page_p, 0, npages, page_size,
            					    kbytes_to_be_written_per_sec) == malloc_io_page_p)))
            #endif /* HPUX */
            	{
            	  /* It is likely that we run of space. The partition where the volume was created has been used since we
            	   * checked above. */
            
            	  max_npages = fileio_get_number_of_partition_free_pages (vol_label_p, page_size);
            
            	  fileio_dismount (thread_p, vol_fd);
            	  fileio_unformat (thread_p, vol_label_p);
            	  free_and_init (malloc_io_page_p);
            	  if (er_errid () != ER_INTERRUPTED)
            	    {
            	      er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_FORMAT_OUT_OF_SPACE, 5, vol_label_p, npages,
            		      (offset / 1024), max_npages, (long long) ((page_size / 1024) * max_npages));
            	    }
            	  vol_fd = NULL_VOLDES;
            	  return vol_fd;
            	}
            
            #if defined(WINDOWS)
                  fileio_dismount (thread_p, vol_fd);
                  vol_fd = fileio_mount (thread_p, NULL, vol_label_p, vol_id, false, false);
            #endif /* WINDOWS */
                }
              else
                {
                  er_set_with_oserror (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_BO_CANNOT_CREATE_VOL, 2, vol_label_p, db_full_name_p);
                }
            
              free_and_init (malloc_io_page_p);
              return vol_fd;
            }
            ```
            
        - 설명 :
        - 코드 (fileio_is_volume_exist)
            
            ```cpp
            /*
             * fileio_is_volume_exist () - Find if a volume exist
             *   return: true/false
             *   vlabel(in): Volume label
             */
            bool
            fileio_is_volume_exist (const char *vol_label_p)
            {
              int vol_fd;
            
            #if !defined(CS_MODE)
              /* Is volume already mounted ? */
              vol_fd = fileio_find_volume_descriptor_with_label (vol_label_p);
              if (vol_fd != NULL_VOLDES)
                {
                  return true;
                }
            #endif /* !CS_MODE */
            
              /* Check the existance of the file by opening the file */
              vol_fd = fileio_open (vol_label_p, O_RDONLY, 0);
              if (vol_fd == NULL_VOLDES)
                {
                  if (errno == ENOENT)
            	{
            	  return false;
            	}
                }
              else
                {
                  fileio_close (vol_fd);
                }
            
              return true;
            }
            ```
            
            - 코드 (fileio_find_volume_descriptor_with_label)
                
                ```cpp
                /*
                 * fileio_find_volume_descriptor_with_label () - Find the volume descriptor given the volume label/name
                 *   return: Volume Name/label
                 *   vlabel(in): I/O volume descriptor
                 */
                int
                fileio_find_volume_descriptor_with_label (const char *vol_label_p)
                {
                  FILEIO_VOLUME_INFO *vol_info_p;
                  FILEIO_SYSTEM_VOLUME_INFO *sys_vol_info_p;
                  int vol_fd = NULL_VOLDES;
                  int rv;
                  APPLY_ARG arg = { 0 };
                
                  FILEIO_CHECK_AND_INITIALIZE_VOLUME_HEADER_CACHE (NULL_VOLDES);
                  rv = pthread_mutex_lock (&fileio_Sys_vol_info_header.mutex);
                  arg.vol_label = vol_label_p;
                  sys_vol_info_p = fileio_find_system_volume (NULL, fileio_is_system_volume_label_equal, &arg);
                  if (sys_vol_info_p)
                    {
                      vol_fd = sys_vol_info_p->vdes;
                      pthread_mutex_unlock (&fileio_Sys_vol_info_header.mutex);
                      return vol_fd;
                    }
                
                  pthread_mutex_unlock (&fileio_Sys_vol_info_header.mutex);
                
                  arg.vol_label = vol_label_p;
                  vol_info_p = fileio_traverse_permanent_volume (NULL, fileio_is_volume_label_equal, &arg);
                  if (vol_info_p)
                    {
                      return vol_info_p->vdes;
                    }
                
                  arg.vol_label = vol_label_p;
                  vol_info_p = fileio_traverse_temporary_volume (NULL, fileio_is_volume_label_equal, &arg);
                  if (vol_info_p)
                    {
                      return vol_info_p->vdes;
                    }
                
                  return vol_fd;
                }
                ```
                
    - fileio_synchronize_all
        - 코드
            
            ```cpp
            /*
             * fileio_synchronize_all () - Synchronize all database volumes with disk
             *   return:
             *   include_log(in):
             */
            int
            fileio_synchronize_all (THREAD_ENTRY * thread_p, bool is_include)
            {
              int success = NO_ERROR;
              bool all_sync = false;
              APPLY_ARG arg = { 0 };
            #if defined (SERVER_MODE) || defined (SA_MODE)
              PERF_UTIME_TRACKER time_track;
            
              PERF_UTIME_TRACKER_START (thread_p, &time_track);
            #endif /* defined (SERVER_MODE) || defined (SA_MODE) */
            
              arg.vol_id = NULL_VOLID;
            
              er_stack_push ();
            
              if (is_include)
                {
                  /* Flush logs. */
                  (void) fileio_traverse_system_volume (thread_p, fileio_synchronize_sys_volume, &arg);
                }
            
            #if !defined (CS_MODE)
              /* Flush DWB before volume data. */
              success = dwb_flush_force (thread_p, &all_sync);
            #endif
            
              /* Check whether the volumes were flushed. */
              if (success == NO_ERROR && all_sync == false)
                {
                  /* Flush volume data. */
                  (void) fileio_traverse_permanent_volume (thread_p, fileio_synchronize_volume, &arg);
            
                  if (er_errid () == ER_IO_SYNC)
            	{
            	  success = ER_FAILED;
            	}
                }
            
              er_stack_pop ();
            
            #if defined (SERVER_MODE) || defined (SA_MODE)
              PERF_UTIME_TRACKER_TIME (thread_p, &time_track, PSTAT_FILE_IOSYNC_ALL);
            #endif /* defined (SERVER_MODE) || defined (SA_MODE) */
            
              return success;
            }
            ```
            
        - 설명 :
    - dwb_create_blocks
        - 코드
            
            ```cpp
            /*
             * dwb_create_blocks () - Create the blocks.
             *
             * return   : Error code.
             * thread_p (in) : The thread entry.
             * num_blocks(in): The number of blocks.
             * num_block_pages(in): The number of block pages.
             * p_blocks(out): The created blocks.
             */
            STATIC_INLINE int
            dwb_create_blocks (THREAD_ENTRY * thread_p, unsigned int num_blocks, unsigned int num_block_pages,
            		   DWB_BLOCK ** p_blocks)
            {
              DWB_BLOCK *blocks = NULL;
              char *blocks_write_buffer[DWB_MAX_BLOCKS];
              FLUSH_VOLUME_INFO *flush_volumes_info[DWB_MAX_BLOCKS];
              DWB_SLOT *slots[DWB_MAX_BLOCKS];
              unsigned int block_buffer_size, i, j;
              int error_code;
              FILEIO_PAGE *io_page;
            
              assert (num_blocks <= DWB_MAX_BLOCKS);
            
              *p_blocks = NULL;
            
              for (i = 0; i < DWB_MAX_BLOCKS; i++)
                {
                  blocks_write_buffer[i] = NULL;
                  slots[i] = NULL;
                  flush_volumes_info[i] = NULL;
                }
            
              blocks = (DWB_BLOCK *) malloc (num_blocks * sizeof (DWB_BLOCK));
              if (blocks == NULL)
                {
                  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1, num_blocks * sizeof (DWB_BLOCK));
                  error_code = ER_OUT_OF_VIRTUAL_MEMORY;
                  goto exit_on_error;
                }
              memset (blocks, 0, num_blocks * sizeof (DWB_BLOCK));
            
              block_buffer_size = num_block_pages * IO_PAGESIZE;
              for (i = 0; i < num_blocks; i++)
                {
                  blocks_write_buffer[i] = (char *) malloc (block_buffer_size * sizeof (char));
                  if (blocks_write_buffer[i] == NULL)
            	{
            	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1, block_buffer_size * sizeof (char));
            	  error_code = ER_OUT_OF_VIRTUAL_MEMORY;
            	  goto exit_on_error;
            	}
                  memset (blocks_write_buffer[i], 0, block_buffer_size * sizeof (char));
                }
            
              for (i = 0; i < num_blocks; i++)
                {
                  slots[i] = (DWB_SLOT *) malloc (num_block_pages * sizeof (DWB_SLOT));
                  if (slots[i] == NULL)
            	{
            	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1, num_block_pages * sizeof (DWB_SLOT));
            	  error_code = ER_OUT_OF_VIRTUAL_MEMORY;
            	  goto exit_on_error;
            	}
                  memset (slots[i], 0, num_block_pages * sizeof (DWB_SLOT));
                }
            
              for (i = 0; i < num_blocks; i++)
                {
                  flush_volumes_info[i] = (FLUSH_VOLUME_INFO *) malloc (num_block_pages * sizeof (FLUSH_VOLUME_INFO));
                  if (flush_volumes_info[i] == NULL)
            	{
            	  er_set (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_OUT_OF_VIRTUAL_MEMORY, 1,
            		  num_block_pages * sizeof (FLUSH_VOLUME_INFO));
            	  error_code = ER_OUT_OF_VIRTUAL_MEMORY;
            	  goto exit_on_error;
            	}
                  memset (flush_volumes_info[i], 0, num_block_pages * sizeof (FLUSH_VOLUME_INFO));
                }
            
              for (i = 0; i < num_blocks; i++)
                {
                  /* No need to initialize FILEIO_PAGE header here, since is overwritten before flushing */
                  for (j = 0; j < num_block_pages; j++)
            	{
            	  io_page = (FILEIO_PAGE *) (blocks_write_buffer[i] + j * IO_PAGESIZE);
            
            	  fileio_initialize_res (thread_p, io_page, IO_PAGESIZE);
            	  dwb_initialize_slot (&slots[i][j], io_page, j, i);
            	}
            
                  dwb_initialize_block (&blocks[i], i, 0, blocks_write_buffer[i], slots[i], flush_volumes_info[i], 0,
            			    num_block_pages);
                }
            
              *p_blocks = blocks;
            
              return NO_ERROR;
            
            exit_on_error:
              for (i = 0; i < DWB_MAX_BLOCKS; i++)
                {
                  if (slots[i] != NULL)
            	{
            	  free_and_init (slots[i]);
            	}
            
                  if (blocks_write_buffer[i] != NULL)
            	{
            	  free_and_init (blocks_write_buffer[i]);
            	}
            
                  if (flush_volumes_info[i] != NULL)
            	{
            	  free_and_init (flush_volumes_info[i]);
            	}
                }
            
              if (blocks != NULL)
                {
                  free_and_init (blocks);
                }
            
              return error_code;
            }
            ```
            
        - 설명 :
    - dwb_init_wait_queue
        - 코드
            
            ```cpp
            /*
             * dwb_init_wait_queue () - Intialize wait queue.
             *
             * return   : Nothing.
             * wait_queue (in/out) : The wait queue.
             */
            STATIC_INLINE void
            dwb_init_wait_queue (DWB_WAIT_QUEUE * wait_queue)
            {
              wait_queue->head = NULL;
              wait_queue->tail = NULL;
              wait_queue->count = 0;
            
              wait_queue->free_list = NULL;
              wait_queue->free_count = 0;
            }
            ```
            
        - 설명 :
    - dwb_Global.slots_hashmap.init
        - 코드
            
            ```cpp
            template <class Key, class T>
              void
              hashmap<Key, T>::init (tran::system &transys, size_t hash_size, size_t freelist_block_size,
            			 size_t freelist_block_count, lf_entry_descriptor &edesc)
              {
                m_freelist = new freelist_type (transys, freelist_block_size, freelist_block_count);
            
                m_edesc = &edesc;
            
                m_size = hash_size;
                m_buckets = new T *[m_size] ();
            
                m_backbuffer = new T *[m_size] ();
                for (size_t i = 0; i < m_size; i++)
                  {
            	m_backbuffer[i] = address_type::set_adress_mark (NULL);
                  }
              }
            ```
            
        - 설명 :
    - DWB_RESET_POSITION
        - 코드
            
            ```cpp
            #define DWB_RESET_POSITION(position_with_flags) \
              ((position_with_flags) & DWB_FLAG_MASK)
            ```
            
        - 설명 :
    - DWB_STARTS_CREATION
        - 코드
            
            ```cpp
            #define DWB_STARTS_CREATION(position_with_flags) \
              ((position_with_flags) | DWB_CREATE)
            ```
            
        - 설명 :
    - fileio_dismount
        - 코드
            
            ```cpp
            /*
             * fileio_dismount () - Dismount the volume associated with the given volume
             *                  descriptor
             *   return: void
             *   vdes(in): Volume descriptor
             */
            void
            fileio_dismount (THREAD_ENTRY * thread_p, int vol_fd)
            {
              const char *vlabel;
            #if !defined(WINDOWS)
              FILEIO_LOCKF_TYPE lockf_type;
            #endif /* !WINDOWS */
              /*
               * Make sure that all dirty pages of the volume are forced to disk. This
               * is needed since a close of a file and program exist, does not imply
               * that the dirty pages of the file (or files that the program opened) are
               * forced to disk.
               */
              vlabel = fileio_get_volume_label_by_fd (vol_fd, PEEK);
            
              (void) fileio_synchronize (thread_p, vol_fd, vlabel, FILEIO_SYNC_ALSO_FLUSH_DWB);
            
            #if !defined(WINDOWS)
              lockf_type = fileio_get_lockf_type (vol_fd);
              if (lockf_type != FILEIO_NOT_LOCKF)
                {
                  fileio_unlock (vlabel, vol_fd, lockf_type);
                }
            #endif /* !WINDOWS */
            
              fileio_close (vol_fd);
            
              /* Decache volume information even during errors */
              fileio_decache (thread_p, vol_fd);
            }
            ```
            
        - 설명 :
    - fileio_unformat
        - 코드
            
            ```cpp
            /*
             * fileio_unformat () - DESTROY A VOLUME
             *   return: void
             *   vlabel(in): Label of volume to unformat
             *
             * Note: If the volume is mounted, it is dismounted. Then, the volume is
             *       destroyed/unformatted.
             */
            void
            fileio_unformat (THREAD_ENTRY * thread_p, const char *vol_label_p)
            {
              fileio_unformat_and_rename (thread_p, vol_label_p, NULL);
            }
            ```
            
        - 설명 :
        - fileio_unformat_and_rename
            - 코드
                
                ```cpp
                /*
                 * fileio_unformat_and_rename () - DESTROY A VOLUME
                 *   return: void
                 *   vol_label(in): Label of volume to unformat
                 *   new_vlabel(in): New volume label. if NULL, volume will be deleted
                 *
                 * Note: If the volume is mounted, it is dismounted. Then, the volume is
                 *       destroyed/unformatted.
                 */
                void
                fileio_unformat_and_rename (THREAD_ENTRY * thread_p, const char *vol_label_p, const char *new_label_p)
                {
                #if defined (EnableThreadMonitoring)
                  TSC_TICKS start_tick, end_tick;
                  TSCTIMEVAL elapsed_time;
                #endif
                #if !defined(CS_MODE)
                  int vol_fd;
                  char vlabel_p[PATH_MAX];
                
                  /* Dismount the volume if it is mounted */
                  vol_fd = fileio_find_volume_descriptor_with_label (vol_label_p);
                  if (vol_fd != NULL_VOLDES)
                    {
                      /* if vol_label_p is a pointer of global vinfo->vlabel, It can be reset in fileio_dismount */
                      strcpy (vlabel_p, vol_label_p);
                      vol_label_p = vlabel_p;
                      fileio_dismount (thread_p, vol_fd);
                    }
                #endif /* !CS_MODE */
                
                #if defined (EnableThreadMonitoring)
                  if (0 < prm_get_integer_value (PRM_ID_MNT_WAITING_THREAD))
                    {
                      tsc_getticks (&start_tick);
                    }
                #endif
                
                  if (new_label_p == NULL)
                    {
                      (void) remove (vol_label_p);
                    }
                  else
                    {
                      if (os_rename_file (vol_label_p, new_label_p) != NO_ERROR)
                	{
                	  er_set_with_oserror (ER_ERROR_SEVERITY, ARG_FILE_LINE, ER_IO_RENAME_FAIL, 2, vol_label_p, new_label_p);
                	}
                    }
                
                #if defined (EnableThreadMonitoring)
                  if (0 < prm_get_integer_value (PRM_ID_MNT_WAITING_THREAD))
                    {
                      tsc_getticks (&end_tick);
                      tsc_elapsed_time_usec (&elapsed_time, end_tick, start_tick);
                    }
                
                  if (MONITOR_WAITING_THREAD (elapsed_time))
                    {
                      er_set (ER_NOTIFICATION_SEVERITY, ARG_FILE_LINE, ER_MNT_WAITING_THREAD, 2, "file remove",
                	      prm_get_integer_value (PRM_ID_MNT_WAITING_THREAD));
                      er_log_debug (ARG_FILE_LINE, "fileio_unformat: %6d.%06d\n", elapsed_time.tv_sec, elapsed_time.tv_usec);
                    }
                #endif
                
                  er_log_debug (ARG_FILE_LINE, "Destroyed volume %s\n", vol_label_p);
                }
                ```
                
            - 설명 :
    - dwb_finalize_block
        - 코드
            
            ```cpp
            /*
             * dwb_finalize_block () - Finalize a block.
             *
             * return   : Nothing
             * block (in) : Double write buffer block.
             */
            STATIC_INLINE void
            dwb_finalize_block (DWB_BLOCK * block)
            {
              if (block->slots != NULL)
                {
                  free_and_init (block->slots);
                }
              /* destroy block write buffer */
              if (block->write_buffer != NULL)
                {
                  free_and_init (block->write_buffer);
                }
              if (block->flush_volumes_info != NULL)
                {
                  free_and_init (block->flush_volumes_info);
                }
            
              dwb_destroy_wait_queue (&block->wait_queue, &block->mutex);
            
              pthread_mutex_destroy (&block->mutex);
            }
            ```
            
        - 설명 :